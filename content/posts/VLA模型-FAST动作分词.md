
## 动作分词是怎样影响VAL训练的

要理解分词方案如何影响学习表现，我们需要关注学习目标本身。从根本上说，自回归模型训练时会在给定所有之前的令牌时预测下一个令牌。因此，它们的学习信号与给 
 的边际信息内容成正比。关键是，使用朴素的每时间步分词方案时，随着训练信号控制频率的增加，边际信息趋近于零 ：对于平滑信号，随着时间步变短，每时间步的变化成比例下降。
 这大大减慢了训练中的收敛速度，使拟合复杂高频数据集变得具有挑战性。事实上，这些挑战在以往工作中已被观察到。
 例如，OpenVLA 在低频 BridgeV2 和 RT-1 数据集上表现良好，但在高频 DROID 数据集 中却难以适应 [39]。 我们的案例研究结果强调了为机器人动作设计更好的令牌化方案的重要性。

 ## 实验

 测试了openvla pi0模型，使用fase分词进行自回归训练
 fast对action token进行分词，然后将这些token覆盖语言模型词表中最少使用的token
 全参数训练，没有冻结


 好的，我们来深度拆解 **FAST (Frequency-space Action Sequence Tokenization)** 算法。

为了让你看清每一个字节是怎么变的，我们不使用复杂的 50Hz 数据，而是构建一个**极简模型**：
*   **场景**：机械臂的一个关节（比如夹爪）在 **8个时间步** 内完成一次“张开”的动作。
*   **数据**：`[10, 20, 40, 60, 80, 90, 95, 100]`（单位：毫米，逐渐张开）。

我们将跟随这个数据，走完 **编码 (Encoding)** 和 **解码 (Decoding)** 的全程。

---

### 第一阶段：编码 (Encoding) —— 从动作到 Token

#### 1. 归一化 (Normalization)
FAST 需要把数据统一到 $[-1, 1]$ 之间。
假设数据的理论最大值是 100，最小值是 0。
*   公式：$x_{new} = \frac{x - 50}{50}$
*   **原始数据**：`[10, 20, 40, 60, 80, 90, 95, 100]`
*   **归一化后**：`[-0.8, -0.6, -0.2, 0.2, 0.6, 0.8, 0.9, 1.0]`

#### 2. 离散余弦变换 (DCT) —— 转换视角
这是魔法发生的地方。DCT 不看“第几秒在哪里”，而是看“这个波形是怎么合成的”。
*   这个动作整体是**上升**的（低频强）。
*   这个动作非常**平滑**，没有抖动（高频弱）。

经过 DCT 变换公式计算（模拟数值）：
*   **DCT系数**：`[1.9, -1.8, -0.3, 0.05, 0.02, 0.01, -0.01, 0.0]`
    *   **1.9 (直流分量)**：代表平均高度。
    *   **-1.8 (低频)**：代表主要的上升趋势（能量最大）。
    *   **-0.3 (中频)**：代表曲线的弯曲程度。
    *   **后面的一堆小数 (高频)**：代表细节和噪声。因为动作很平滑，所以这些值非常接近 0。

#### 3. 量化与修剪 (Quantization & Rounding)
计算机不需要无限精度。FAST 引入一个缩放因子（假设 $\gamma=100$）并四舍五入。
*   公式：$Int = \text{Round}(Float \times 100)$

| 频率类型 | 原始 DCT | 乘以 100 | 四舍五入 (Int) |
| :--- | :--- | :--- | :--- |
| 平均值 | 1.9 | 190 | **190** |
| 主趋势 | -1.8 | -180 | **-180** |
| 弯曲度 | -0.3 | -30 | **-30** |
| 细节1 | 0.05 | 5 | **5** |
| 细节2 | 0.02 | 2 | **0** (被舍弃!) |
| 细节3 | 0.01 | 1 | **0** (被舍弃!) |
| 细节4 | -0.01 | -1 | **0** (被舍弃!) |
| 噪声 | 0.0 | 0 | **0** (被舍弃!) |

**现在的序列**：`[190, -180, -30, 5, 0, 0, 0, 0]`
> **注意**：原本 8 个各不相同的数字，现在尾部出现了一串连续的 **0**。这就创造了“稀疏性”。

#### 4. 展平与排序 (Flattening)
如果有多个关节（比如关节 A 和 关节 B），FAST **不会**按 `[A全套, B全套]` 排序。
它采用 **“低频优先 (Low-frequency components first)”** 策略。
<alphaxiv-paper-citation title="Flattening Strategy" page="5" first="Low-frequency components first" last="stable policy rollouts." />

*   假设我们只有这一个关节，这一步就是简单的序列：
    `Sequence = [190, -180, -30, 5, 0, 0, 0, 0]`

#### 5. 字节对编码 (BPE) —— 终极压缩
这是 LLM 处理文本的方法。FAST 训练了一个 BPE 词表，专门用来“吃掉”重复的模式。

假设我们的 BPE 词表里学到了这样的规则：
1.  规则 A: `0, 0` $\rightarrow$ 合并为符号 `<Z2>`
2.  规则 B: `<Z2>, <Z2>` $\rightarrow$ 合并为符号 `<Z4>` (即4个零)
3.  规则 C: `190, -180` $\rightarrow$ 合并为符号 `<UP_TREND>` (常见的上升起手式)

**压缩过程：**
*   原始：`[190, -180, -30, 5, 0, 0, 0, 0]`
*   应用规则 A：`[190, -180, -30, 5, <Z2>, <Z2>]`
*   应用规则 B：`[190, -180, -30, 5, <Z4>]`
*   应用规则 C：`[<UP_TREND>, -30, 5, <Z4>]`

**最终结果 (Token IDs)**：
假设词表中：
*   `<UP_TREND>` 的 ID 是 **305**
*   `-30` 的 ID 是 **122**
*   `5` 的 ID 是 **55**
*   `<Z4>` 的 ID 是 **900**

**模型最终看到的 Token 序列**：`[305, 122, 55, 900]`
> **从 8 个浮点数 $\rightarrow$ 4 个整数。压缩率 50%（在实际高频数据中，压缩率通常高达 90% 以上，因为会有几十个 0）。**

---

### 第二阶段：解码 (Decoding) —— 还原动作

当 $\pi_0$ 模型预测出 `[305, 122, 55, 900]` 后，机器人怎么动？

#### 1. 逆 BPE (Inverse BPE)
查表，把 Token 拆回整数序列。
*   `305` $\rightarrow$ `190, -180`
*   `122` $\rightarrow$ `-30`
*   `55` $\rightarrow$ `5`
*   `900` $\rightarrow$ `0, 0, 0, 0`
*   **恢复序列**：`[190, -180, -30, 5, 0, 0, 0, 0]`

#### 2. 逆量化 (Inverse Quantization)
除以之前的缩放因子 $\gamma=100$。
*   `190` / 100 = **1.9**
*   `5` / 100 = **0.05**
*   `0` / 100 = **0.0**
*   **恢复 DCT 系数**：`[1.9, -1.8, -0.3, 0.05, 0.0, 0.0, 0.0, 0.0]`

> **对比原始 DCT**：原始的 `0.02` 和 `0.01` 变成了 `0.0`。这就是**有损压缩**，细节丢失了，但主要形状还在。

#### 3. 逆 DCT (Inverse DCT)
利用这些系数，通过 IDCT 公式重建时间序列。
这就好比用 `1.9` 倍的基础波 + `-1.8` 倍的一阶波 + ... 叠加。

*   **重建出的归一化数据**（模拟计算结果）：
    `[-0.80, -0.61, -0.19, 0.20, 0.60, 0.81, 0.90, 0.99]`

#### 4. 反归一化 (Denormalization)
映射回真实物理单位 [0, 100]。
*   $x = x_{norm} \times 50 + 50$
*   -0.80 $\rightarrow$ **10.0**
*   -0.61 $\rightarrow$ **19.5** (原值 20)
*   ...
*   0.99 $\rightarrow$ **99.5** (原值 100)

**最终对比：**
*   原始：`10, 20, 40, 60, 80, 90, 95, 100`
*   解码：`10, 19.5, 40.5, 60, 80, 90.5, 95, 99.5`

**结论：** 虽然数字有一点点微小的误差（因为量化丢弃了高频细节），但**动作的整体轨迹和流畅度被完美保留了**。这就是 FAST 算法能够让机器人“丝滑”运动的核心原理。
