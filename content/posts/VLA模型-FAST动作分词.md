
## 动作分词是怎样影响VAL训练的

要理解分词方案如何影响学习表现，我们需要关注学习目标本身。从根本上说，自回归模型训练时会在给定所有之前的令牌时预测下一个令牌。因此，它们的学习信号与给 
 的边际信息内容成正比。关键是，使用朴素的每时间步分词方案时，随着训练信号控制频率的增加，边际信息趋近于零 ：对于平滑信号，随着时间步变短，每时间步的变化成比例下降。
 这大大减慢了训练中的收敛速度，使拟合复杂高频数据集变得具有挑战性。事实上，这些挑战在以往工作中已被观察到。
 例如，OpenVLA 在低频 BridgeV2 和 RT-1 数据集上表现良好，但在高频 DROID 数据集 中却难以适应 [39]。 我们的案例研究结果强调了为机器人动作设计更好的令牌化方案的重要性。

 ## 实验

 测试了openvla pi0模型，使用fase分词进行自回归训练
 fast对action token进行分词，然后将这些token覆盖语言模型词表中最少使用的token
 全参数训练，没有冻结


 好的，我们来深度拆解 **FAST (Frequency-space Action Sequence Tokenization)** 算法。

为了让你看清每一个字节是怎么变的，我们不使用复杂的 50Hz 数据，而是构建一个**极简模型**：
*   **场景**：机械臂的一个关节（比如夹爪）在 **8个时间步** 内完成一次“张开”的动作。
*   **数据**：`[10, 20, 40, 60, 80, 90, 95, 100]`（单位：毫米，逐渐张开）。

我们将跟随这个数据，走完 **编码 (Encoding)** 和 **解码 (Decoding)** 的全程。

---

### 第一阶段：编码 (Encoding) —— 从动作到 Token

#### 1. 归一化 (Normalization)
FAST 需要把数据统一到 $[-1, 1]$ 之间。
假设数据的理论最大值是 100，最小值是 0。
*   公式：$x_{new} = \frac{x - 50}{50}$
*   **原始数据**：`[10, 20, 40, 60, 80, 90, 95, 100]`
*   **归一化后**：`[-0.8, -0.6, -0.2, 0.2, 0.6, 0.8, 0.9, 1.0]`

#### 2. 离散余弦变换 (DCT) —— 转换视角
这是魔法发生的地方。DCT 不看“第几秒在哪里”，而是看“这个波形是怎么合成的”。
*   这个动作整体是**上升**的（低频强）。
*   这个动作非常**平滑**，没有抖动（高频弱）。

经过 DCT 变换公式计算（模拟数值）：
*   **DCT系数**：`[1.9, -1.8, -0.3, 0.05, 0.02, 0.01, -0.01, 0.0]`
    *   **1.9 (直流分量)**：代表平均高度。
    *   **-1.8 (低频)**：代表主要的上升趋势（能量最大）。
    *   **-0.3 (中频)**：代表曲线的弯曲程度。
    *   **后面的一堆小数 (高频)**：代表细节和噪声。因为动作很平滑，所以这些值非常接近 0。

#### 3. 量化与修剪 (Quantization & Rounding)
计算机不需要无限精度。FAST 引入一个缩放因子（假设 $\gamma=100$）并四舍五入。
*   公式：$Int = \text{Round}(Float \times 100)$

| 频率类型 | 原始 DCT | 乘以 100 | 四舍五入 (Int) |
| :--- | :--- | :--- | :--- |
| 平均值 | 1.9 | 190 | **190** |
| 主趋势 | -1.8 | -180 | **-180** |
| 弯曲度 | -0.3 | -30 | **-30** |
| 细节1 | 0.05 | 5 | **5** |
| 细节2 | 0.02 | 2 | **0** (被舍弃!) |
| 细节3 | 0.01 | 1 | **0** (被舍弃!) |
| 细节4 | -0.01 | -1 | **0** (被舍弃!) |
| 噪声 | 0.0 | 0 | **0** (被舍弃!) |

**现在的序列**：`[190, -180, -30, 5, 0, 0, 0, 0]`
> **注意**：原本 8 个各不相同的数字，现在尾部出现了一串连续的 **0**。这就创造了“稀疏性”。

#### 4. 展平与排序 (Flattening)
如果有多个关节（比如关节 A 和 关节 B），FAST **不会**按 `[A全套, B全套]` 排序。
它采用 **“低频优先 (Low-frequency components first)”** 策略。
<alphaxiv-paper-citation title="Flattening Strategy" page="5" first="Low-frequency components first" last="stable policy rollouts." />

*   假设我们只有这一个关节，这一步就是简单的序列：
    `Sequence = [190, -180, -30, 5, 0, 0, 0, 0]`

#### 5. 字节对编码 (BPE) —— 终极压缩
这是 LLM 处理文本的方法。FAST 训练了一个 BPE 词表，专门用来“吃掉”重复的模式。

假设我们的 BPE 词表里学到了这样的规则：
1.  规则 A: `0, 0` $\rightarrow$ 合并为符号 `<Z2>`
2.  规则 B: `<Z2>, <Z2>` $\rightarrow$ 合并为符号 `<Z4>` (即4个零)
3.  规则 C: `190, -180` $\rightarrow$ 合并为符号 `<UP_TREND>` (常见的上升起手式)

**压缩过程：**
*   原始：`[190, -180, -30, 5, 0, 0, 0, 0]`
*   应用规则 A：`[190, -180, -30, 5, <Z2>, <Z2>]`
*   应用规则 B：`[190, -180, -30, 5, <Z4>]`
*   应用规则 C：`[<UP_TREND>, -30, 5, <Z4>]`

**最终结果 (Token IDs)**：
假设词表中：
*   `<UP_TREND>` 的 ID 是 **305**
*   `-30` 的 ID 是 **122**
*   `5` 的 ID 是 **55**
*   `<Z4>` 的 ID 是 **900**

**模型最终看到的 Token 序列**：`[305, 122, 55, 900]`
> **从 8 个浮点数 $\rightarrow$ 4 个整数。压缩率 50%（在实际高频数据中，压缩率通常高达 90% 以上，因为会有几十个 0）。**

---

### 第二阶段：解码 (Decoding) —— 还原动作

当 $\pi_0$ 模型预测出 `[305, 122, 55, 900]` 后，机器人怎么动？

#### 1. 逆 BPE (Inverse BPE)
查表，把 Token 拆回整数序列。
*   `305` $\rightarrow$ `190, -180`
*   `122` $\rightarrow$ `-30`
*   `55` $\rightarrow$ `5`
*   `900` $\rightarrow$ `0, 0, 0, 0`
*   **恢复序列**：`[190, -180, -30, 5, 0, 0, 0, 0]`

#### 2. 逆量化 (Inverse Quantization)
除以之前的缩放因子 $\gamma=100$。
*   `190` / 100 = **1.9**
*   `5` / 100 = **0.05**
*   `0` / 100 = **0.0**
*   **恢复 DCT 系数**：`[1.9, -1.8, -0.3, 0.05, 0.0, 0.0, 0.0, 0.0]`

> **对比原始 DCT**：原始的 `0.02` 和 `0.01` 变成了 `0.0`。这就是**有损压缩**，细节丢失了，但主要形状还在。

#### 3. 逆 DCT (Inverse DCT)
利用这些系数，通过 IDCT 公式重建时间序列。
这就好比用 `1.9` 倍的基础波 + `-1.8` 倍的一阶波 + ... 叠加。

*   **重建出的归一化数据**（模拟计算结果）：
    `[-0.80, -0.61, -0.19, 0.20, 0.60, 0.81, 0.90, 0.99]`

#### 4. 反归一化 (Denormalization)
映射回真实物理单位 [0, 100]。
*   $x = x_{norm} \times 50 + 50$
*   -0.80 $\rightarrow$ **10.0**
*   -0.61 $\rightarrow$ **19.5** (原值 20)
*   ...
*   0.99 $\rightarrow$ **99.5** (原值 100)

**最终对比：**
*   原始：`10, 20, 40, 60, 80, 90, 95, 100`
*   解码：`10, 19.5, 40.5, 60, 80, 90.5, 95, 99.5`

**结论：** 虽然数字有一点点微小的误差（因为量化丢弃了高频细节），但**动作的整体轨迹和流畅度被完美保留了**。这就是 FAST 算法能够让机器人“丝滑”运动的核心原理。


---

为了让你彻底理解 DCT（离散余弦变换）的公式，我们继续使用“**配方与积木**”的比喻。

不要被数学符号吓到，DCT 的本质其实就是**“相似度匹配”**。

---

### 1. 核心思想：把动作拆解成“波”
DCT 认为：**世界上任何复杂的动作轨迹，都可以看作是若干个不同频率的余弦波（Cosine Waves）叠加而成的。**

*   **时域 (Time Domain)**：你告诉机器人第1秒在哪，第2秒在哪……
    *   就像：`[10, 20, 40, 60]`
*   **频域 (Frequency Domain)**：你告诉机器人“用多少个大波浪，加上多少个小抖动”。
    *   就像：`100份的直流电 + 50份的低频波 + 0份的高频波`

---

### 2. DCT 变换公式 (Forward DCT)

这是将动作数据 $x$ 转换为系数 $X$ 的公式。

$$ X_k = \sum_{n=0}^{N-1} x_n \cdot \underbrace{\cos \left[ \frac{\pi}{N} \left(n + \frac{1}{2}\right) k \right]}_{\text{基函数 (Basis Function)}} $$

我们把这个公式拆开看，它其实只做了一件事：**点积（Dot Product）计算相似度**。

#### 变量说明
*   $N$：总步数（比如 4 步）。
*   $x_n$：第 $n$ 步的动作值（原始数据）。
*   $k$：当前我们正在计算第 $k$ 个频率（$k=0$ 是直流/平均，$k=1$ 是最低频，$k=N-1$ 是最高频）。
*   $X_k$：**结果系数**。如果这个值很大，说明原始动作里“含有大量”这种频率的波。

#### 直观演示：它是怎么算的？

假设我们要处理一个简单的 4 步动作序列：$x = [10, 20, 30, 40]$（一个完美的上升斜坡）。
$N=4$。

**第一步：计算 $X_0$ (k=0, 直流分量/平均值)**
*   当 $k=0$ 时，公式里的 $\cos(0)$ 永远等于 **1**。
*   基函数（波形）：`[1, 1, 1, 1]` （一条水平线）。
*   计算：
    $$ X_0 = 10\times1 + 20\times1 + 30\times1 + 40\times1 = 100 $$
*   **含义**：这代表了整个动作的“能量总和”或“平均高度”。

**第二步：计算 $X_1$ (k=1, 低频分量/主要趋势)**
*   这是半个周期的余弦波，形状是“左高右低”的曲线。
*   假设基函数算出来是：`[0.9, 0.4, -0.4, -0.9]`（随时间下降）。
*   原始数据是：`[10, 20, 30, 40]`（随时间上升）。
*   计算点积：
    $$ X_1 = 10\times(0.9) + 20\times(0.4) + 30\times(-0.4) + 40\times(-0.9) $$
    $$ X_1 = 9 + 8 - 12 - 36 = -31 $$
*   **含义**：结果是负的很大值。说明原始数据和这个波形**高度相关**（虽然方向相反）。这个系数 $-31$ 告诉解码器：“这里有一个很强的倾斜趋势！”

**第三步：计算 $X_3$ (k=3, 高频分量/剧烈抖动)**
*   这是一个快速上下跳动的波。
*   基函数假设是：`[0.9, -0.9, 0.9, -0.9]`（以此模拟高频抖动）。
*   原始数据：`[10, 20, 30, 40]`（平滑上升）。
*   计算：
    $$ X_3 = 10\times(0.9) + 20\times(-0.9) + 30\times(0.9) + 40\times(-0.9) $$
    $$ X_3 = 9 - 18 + 27 - 36 = -18 $$
    *(注：在真实归一化和包含更多点的情况下，对于完美的直线，高频系数通常会非常接近 0)*。

---

### 3. 逆 DCT 公式 (Inverse DCT) —— 还原

这是 FAST 解码时的公式。它就是上面过程的逆运算：**加权求和**。

$$ x_n = \sum_{k=0}^{N-1} X_k \cdot \cos \left[ \dots \right] $$

**通俗解释**：
$$ \text{最终动作} = (\text{系数}_0 \times \text{水平线}) + (\text{系数}_1 \times \text{低频波}) + (\text{系数}_2 \times \text{高频波}) + \dots $$

#### 为什么 FAST 能压缩？

回到上面的例子：$x = [10, 20, 30, 40]$。
计算出的系数可能是：`X = [100, -31, 0, 0]`。

*   **编码时**：
    我们发现 $X_2$ 和 $X_3$ 很小（因为动作很平滑，不需要高频波来合成）。
    于是 FAST 把它们**舍弃**，只保留 `[100, -31]`。
    数据量瞬间减少了一半！

*   **解码时**：
    解码器收到 `[100, -31]`。
    $$ \text{动作} \approx 100 \times \text{水平线} + (-31) \times \text{低频波} $$
    它虽然丢失了微小的细节，但完美还原了“平均位置”和“上升趋势”。对于机器人来说，这通常就足够执行任务了。

### 总结公式的意义

1.  **$x_n$** 是积木块的位置（原始数据）。
2.  **$\cos[\dots]$** 是模具（不同频率的波）。
3.  **求和 $\sum$** 是在尝试把积木塞进模具。
4.  **$X_k$** 是匹配得分。

**FAST 的核心逻辑**：机器人动作很平滑 $\rightarrow$ 只有低频模具能匹配上 $\rightarrow$ 高频模具的匹配得分 ($X_k$) 几乎为 0 $\rightarrow$ 把 0 扔掉 $\rightarrow$ **压缩成功**。
