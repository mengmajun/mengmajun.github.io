
## 动作分词是怎样影响VAL训练的

要理解分词方案如何影响学习表现，我们需要关注学习目标本身。从根本上说，自回归模型训练时会在给定所有之前的令牌时预测下一个令牌。因此，它们的学习信号与给 
 的边际信息内容成正比。关键是，使用朴素的每时间步分词方案时，随着训练信号控制频率的增加，边际信息趋近于零 ：对于平滑信号，随着时间步变短，每时间步的变化成比例下降。
 这大大减慢了训练中的收敛速度，使拟合复杂高频数据集变得具有挑战性。事实上，这些挑战在以往工作中已被观察到。
 例如，OpenVLA 在低频 BridgeV2 和 RT-1 数据集上表现良好，但在高频 DROID 数据集 中却难以适应 [39]。 我们的案例研究结果强调了为机器人动作设计更好的令牌化方案的重要性。

 ## 实验

 测试了openvla pi0模型，使用fase分词进行自回归训练
 fast对action token进行分词，然后将这些token覆盖语言模型词表中最少使用的token
 全参数训练，没有冻结


 好的，我们来深度拆解 **FAST (Frequency-space Action Sequence Tokenization)** 算法。

为了让你看清每一个字节是怎么变的，我们不使用复杂的 50Hz 数据，而是构建一个**极简模型**：
*   **场景**：机械臂的一个关节（比如夹爪）在 **8个时间步** 内完成一次“张开”的动作。
*   **数据**：`[10, 20, 40, 60, 80, 90, 95, 100]`（单位：毫米，逐渐张开）。

我们将跟随这个数据，走完 **编码 (Encoding)** 和 **解码 (Decoding)** 的全程。

---

### 第一阶段：编码 (Encoding) —— 从动作到 Token

#### 1. 归一化 (Normalization)
FAST 需要把数据统一到 $[-1, 1]$ 之间。
假设数据的理论最大值是 100，最小值是 0。
*   公式：$x_{new} = \frac{x - 50}{50}$
*   **原始数据**：`[10, 20, 40, 60, 80, 90, 95, 100]`
*   **归一化后**：`[-0.8, -0.6, -0.2, 0.2, 0.6, 0.8, 0.9, 1.0]`

#### 2. 离散余弦变换 (DCT) —— 转换视角
这是魔法发生的地方。DCT 不看“第几秒在哪里”，而是看“这个波形是怎么合成的”。
*   这个动作整体是**上升**的（低频强）。
*   这个动作非常**平滑**，没有抖动（高频弱）。

经过 DCT 变换公式计算（模拟数值）：
*   **DCT系数**：`[1.9, -1.8, -0.3, 0.05, 0.02, 0.01, -0.01, 0.0]`
    *   **1.9 (直流分量)**：代表平均高度。
    *   **-1.8 (低频)**：代表主要的上升趋势（能量最大）。
    *   **-0.3 (中频)**：代表曲线的弯曲程度。
    *   **后面的一堆小数 (高频)**：代表细节和噪声。因为动作很平滑，所以这些值非常接近 0。

#### 3. 量化与修剪 (Quantization & Rounding)
计算机不需要无限精度。FAST 引入一个缩放因子（假设 $\gamma=100$）并四舍五入。
*   公式：$Int = \text{Round}(Float \times 100)$

| 频率类型 | 原始 DCT | 乘以 100 | 四舍五入 (Int) |
| :--- | :--- | :--- | :--- |
| 平均值 | 1.9 | 190 | **190** |
| 主趋势 | -1.8 | -180 | **-180** |
| 弯曲度 | -0.3 | -30 | **-30** |
| 细节1 | 0.05 | 5 | **5** |
| 细节2 | 0.02 | 2 | **0** (被舍弃!) |
| 细节3 | 0.01 | 1 | **0** (被舍弃!) |
| 细节4 | -0.01 | -1 | **0** (被舍弃!) |
| 噪声 | 0.0 | 0 | **0** (被舍弃!) |

**现在的序列**：`[190, -180, -30, 5, 0, 0, 0, 0]`
> **注意**：原本 8 个各不相同的数字，现在尾部出现了一串连续的 **0**。这就创造了“稀疏性”。

#### 4. 展平与排序 (Flattening)
如果有多个关节（比如关节 A 和 关节 B），FAST **不会**按 `[A全套, B全套]` 排序。
它采用 **“低频优先 (Low-frequency components first)”** 策略。
<alphaxiv-paper-citation title="Flattening Strategy" page="5" first="Low-frequency components first" last="stable policy rollouts." />

*   假设我们只有这一个关节，这一步就是简单的序列：
    `Sequence = [190, -180, -30, 5, 0, 0, 0, 0]`

#### 5. 字节对编码 (BPE) —— 终极压缩
这是 LLM 处理文本的方法。FAST 训练了一个 BPE 词表，专门用来“吃掉”重复的模式。

假设我们的 BPE 词表里学到了这样的规则：
1.  规则 A: `0, 0` $\rightarrow$ 合并为符号 `<Z2>`
2.  规则 B: `<Z2>, <Z2>` $\rightarrow$ 合并为符号 `<Z4>` (即4个零)
3.  规则 C: `190, -180` $\rightarrow$ 合并为符号 `<UP_TREND>` (常见的上升起手式)

**压缩过程：**
*   原始：`[190, -180, -30, 5, 0, 0, 0, 0]`
*   应用规则 A：`[190, -180, -30, 5, <Z2>, <Z2>]`
*   应用规则 B：`[190, -180, -30, 5, <Z4>]`
*   应用规则 C：`[<UP_TREND>, -30, 5, <Z4>]`

**最终结果 (Token IDs)**：
假设词表中：
*   `<UP_TREND>` 的 ID 是 **305**
*   `-30` 的 ID 是 **122**
*   `5` 的 ID 是 **55**
*   `<Z4>` 的 ID 是 **900**

**模型最终看到的 Token 序列**：`[305, 122, 55, 900]`
> **从 8 个浮点数 $\rightarrow$ 4 个整数。压缩率 50%（在实际高频数据中，压缩率通常高达 90% 以上，因为会有几十个 0）。**

---

### 第二阶段：解码 (Decoding) —— 还原动作

当 $\pi_0$ 模型预测出 `[305, 122, 55, 900]` 后，机器人怎么动？

#### 1. 逆 BPE (Inverse BPE)
查表，把 Token 拆回整数序列。
*   `305` $\rightarrow$ `190, -180`
*   `122` $\rightarrow$ `-30`
*   `55` $\rightarrow$ `5`
*   `900` $\rightarrow$ `0, 0, 0, 0`
*   **恢复序列**：`[190, -180, -30, 5, 0, 0, 0, 0]`

#### 2. 逆量化 (Inverse Quantization)
除以之前的缩放因子 $\gamma=100$。
*   `190` / 100 = **1.9**
*   `5` / 100 = **0.05**
*   `0` / 100 = **0.0**
*   **恢复 DCT 系数**：`[1.9, -1.8, -0.3, 0.05, 0.0, 0.0, 0.0, 0.0]`

> **对比原始 DCT**：原始的 `0.02` 和 `0.01` 变成了 `0.0`。这就是**有损压缩**，细节丢失了，但主要形状还在。

#### 3. 逆 DCT (Inverse DCT)
利用这些系数，通过 IDCT 公式重建时间序列。
这就好比用 `1.9` 倍的基础波 + `-1.8` 倍的一阶波 + ... 叠加。

*   **重建出的归一化数据**（模拟计算结果）：
    `[-0.80, -0.61, -0.19, 0.20, 0.60, 0.81, 0.90, 0.99]`

#### 4. 反归一化 (Denormalization)
映射回真实物理单位 [0, 100]。
*   $x = x_{norm} \times 50 + 50$
*   -0.80 $\rightarrow$ **10.0**
*   -0.61 $\rightarrow$ **19.5** (原值 20)
*   ...
*   0.99 $\rightarrow$ **99.5** (原值 100)

**最终对比：**
*   原始：`10, 20, 40, 60, 80, 90, 95, 100`
*   解码：`10, 19.5, 40.5, 60, 80, 90.5, 95, 99.5`

**结论：** 虽然数字有一点点微小的误差（因为量化丢弃了高频细节），但**动作的整体轨迹和流畅度被完美保留了**。这就是 FAST 算法能够让机器人“丝滑”运动的核心原理。


---

为了让你彻底理解 DCT（离散余弦变换）的公式，我们继续使用“**配方与积木**”的比喻。

不要被数学符号吓到，DCT 的本质其实就是**“相似度匹配”**。

---

### 1. 核心思想：把动作拆解成“波”
DCT 认为：**世界上任何复杂的动作轨迹，都可以看作是若干个不同频率的余弦波（Cosine Waves）叠加而成的。**

*   **时域 (Time Domain)**：你告诉机器人第1秒在哪，第2秒在哪……
    *   就像：`[10, 20, 40, 60]`
*   **频域 (Frequency Domain)**：你告诉机器人“用多少个大波浪，加上多少个小抖动”。
    *   就像：`100份的直流电 + 50份的低频波 + 0份的高频波`

---

### 2. DCT 变换公式 (Forward DCT)

这是将动作数据 $x$ 转换为系数 $X$ 的公式。

$$ X_k = \sum_{n=0}^{N-1} x_n \cdot \underbrace{\cos \left[ \frac{\pi}{N} \left(n + \frac{1}{2}\right) k \right]}_{\text{基函数 (Basis Function)}} $$

我们把这个公式拆开看，它其实只做了一件事：**点积（Dot Product）计算相似度**。

#### 变量说明
*   $N$：总步数（比如 4 步）。
*   $x_n$：第 $n$ 步的动作值（原始数据）。
*   $k$：当前我们正在计算第 $k$ 个频率（$k=0$ 是直流/平均，$k=1$ 是最低频，$k=N-1$ 是最高频）。
*   $X_k$：**结果系数**。如果这个值很大，说明原始动作里“含有大量”这种频率的波。

#### 直观演示：它是怎么算的？

假设我们要处理一个简单的 4 步动作序列：$x = [10, 20, 30, 40]$（一个完美的上升斜坡）。
$N=4$。

**第一步：计算 $X_0$ (k=0, 直流分量/平均值)**
*   当 $k=0$ 时，公式里的 $\cos(0)$ 永远等于 **1**。
*   基函数（波形）：`[1, 1, 1, 1]` （一条水平线）。
*   计算：
    $$ X_0 = 10\times1 + 20\times1 + 30\times1 + 40\times1 = 100 $$
*   **含义**：这代表了整个动作的“能量总和”或“平均高度”。

**第二步：计算 $X_1$ (k=1, 低频分量/主要趋势)**
*   这是半个周期的余弦波，形状是“左高右低”的曲线。
*   假设基函数算出来是：`[0.9, 0.4, -0.4, -0.9]`（随时间下降）。
*   原始数据是：`[10, 20, 30, 40]`（随时间上升）。
*   计算点积：
    $$ X_1 = 10\times(0.9) + 20\times(0.4) + 30\times(-0.4) + 40\times(-0.9) $$
    $$ X_1 = 9 + 8 - 12 - 36 = -31 $$
*   **含义**：结果是负的很大值。说明原始数据和这个波形**高度相关**（虽然方向相反）。这个系数 $-31$ 告诉解码器：“这里有一个很强的倾斜趋势！”

**第三步：计算 $X_3$ (k=3, 高频分量/剧烈抖动)**
*   这是一个快速上下跳动的波。
*   基函数假设是：`[0.9, -0.9, 0.9, -0.9]`（以此模拟高频抖动）。
*   原始数据：`[10, 20, 30, 40]`（平滑上升）。
*   计算：
    $$ X_3 = 10\times(0.9) + 20\times(-0.9) + 30\times(0.9) + 40\times(-0.9) $$
    $$ X_3 = 9 - 18 + 27 - 36 = -18 $$
    *(注：在真实归一化和包含更多点的情况下，对于完美的直线，高频系数通常会非常接近 0)*。

---

### 3. 逆 DCT 公式 (Inverse DCT) —— 还原

这是 FAST 解码时的公式。它就是上面过程的逆运算：**加权求和**。

$$ x_n = \sum_{k=0}^{N-1} X_k \cdot \cos \left[ \dots \right] $$

**通俗解释**：
$$ \text{最终动作} = (\text{系数}_0 \times \text{水平线}) + (\text{系数}_1 \times \text{低频波}) + (\text{系数}_2 \times \text{高频波}) + \dots $$

#### 为什么 FAST 能压缩？

回到上面的例子：$x = [10, 20, 30, 40]$。
计算出的系数可能是：`X = [100, -31, 0, 0]`。

*   **编码时**：
    我们发现 $X_2$ 和 $X_3$ 很小（因为动作很平滑，不需要高频波来合成）。
    于是 FAST 把它们**舍弃**，只保留 `[100, -31]`。
    数据量瞬间减少了一半！

*   **解码时**：
    解码器收到 `[100, -31]`。
    $$ \text{动作} \approx 100 \times \text{水平线} + (-31) \times \text{低频波} $$
    它虽然丢失了微小的细节，但完美还原了“平均位置”和“上升趋势”。对于机器人来说，这通常就足够执行任务了。

### 总结公式的意义

1.  **$x_n$** 是积木块的位置（原始数据）。
2.  **$\cos[\dots]$** 是模具（不同频率的波）。
3.  **求和 $\sum$** 是在尝试把积木塞进模具。
4.  **$X_k$** 是匹配得分。

**FAST 的核心逻辑**：机器人动作很平滑 $\rightarrow$ 只有低频模具能匹配上 $\rightarrow$ 高频模具的匹配得分 ($X_k$) 几乎为 0 $\rightarrow$ 把 0 扔掉 $\rightarrow$ **压缩成功**。

---


这是一个非常深刻的问题！这两个概念正是 **DCT（离散余弦变换）** 能够打败 **DFT（离散傅里叶变换/正弦变换）** 并成为 JPEG 图片压缩和 FAST 动作压缩核心的原因。

我们一个个来拆解。

---

### 1. 什么是周期？什么是半周期？

我们还是用“转圈”和“摆动”来理解。

#### **全周期 (Full Period, $2\pi$)**
你可以把它想象成**“一次完整的呼吸”**或者**“往返跑”**。
*   **动作**：从最高点出发 $\to$ 降到最低点 $\to$ **再回到最高点**。
*   **形状**：像一个完整的山谷。
*   **机器人例子**：把手伸出去，再缩回来，回到原位。这就是一个周期。

#### **半周期 (Half Period, $\pi$)**
顾名思义，就是全周期的一半。
*   **动作**：从最高点出发 $\to$ 降到最低点（然后就停了）。
*   **形状**：只有下坡路，没有回程。
*   **机器人例子**：把手**伸出去**。
    *   这非常关键！大多数机器人的动作（比如“去拿杯子”），本质上就是一个**半周期**的运动（从起点到终点）。
    *   DCT 的基函数中包含很多这种“半周期”或“四分之一周期”的成分，非常适合描述这种**单向的、平滑的移动**。

---

### 2. 为什么说余弦具有“能量集中”特性？(Energy Compaction)

这是最硬核的部分。为了让你听懂，我们来做一个对比：**余弦 (Cosine)** vs **正弦 (Sine)**。

假设有一段机器人手臂抬起的平滑数据：`[100, 101, 102, ..., 200]`。

#### **理由一：起跑线的区别（边界问题）**

*   **正弦 ($\sin$) 的尴尬**：
    *   正弦函数 $\sin(0) = 0$。它天生强制从 0 开始。
    *   但是你的数据是从 `100` 开始的！
    *   **后果**：为了用正弦波模拟这组数据，你需要无数个高频的正弦波叠加，硬生生把起点从 0 “拉”到 100。这就产生了大量的高频系数（能量分散到了高频）。

*   **余弦 ($\cos$) 的优雅**：
    *   余弦函数 $\cos(0) = 1$。它天生允许非零的起点。
    *   它可以很自然地贴合数据 `100` 的起点，不需要额外的高频波来修补起跑线。
    *   **结果**：只需要一个低频波就能搞定，高频系数全是 0。这就是**能量集中在低频**。

#### **理由二：隐式镜像（DCT 的秘密武器）**

这是 DCT 压缩效率高的真正数学原因。

当我们对一段有限的数据做变换时，数学上假设这段数据会**不断重复**。

*   **如果是 DFT/正弦变换（直接重复）**：
    *   数据：`[低......高]`
    *   重复后：`[低...高] [低...高] [低...高]`
    *   **问题**：在“高”和“低”的连接处，会出现一个**垂直的悬崖（断层）**。
    *   在信号处理中，**任何“悬崖/突变”都需要极其丰富的高频能量才能表示**（这叫吉布斯现象）。这意味着你需要记录大量的高频数据，压缩率很低。

*   **如果是 DCT/余弦变换（镜像重复）**：
    *   DCT 在数学上隐含了一个操作：把数据**镜像对称**后再重复。
    *   数据：`[低......高]`
    *   重复后：`[低......高] [高......低] [低......高]`
    *   **妙处**：注意连接处！`...高] [高...` 和 `...低] [低...`。
    *   **连接处是平滑过渡的，没有悬崖！**
    *   因为整体变得平滑连续了，所以根本不需要高频波来修补断层。所有的能量都老老实实地待在低频部分。

### 总结

1.  **半周期**：就像机器人“单程”伸手动作，不需要缩回来。余弦波的形状天然契合这种动作。
2.  **能量集中**：
    *   **正弦**像是一个必须从 0 开始的固执工匠，遇到非 0 开头的数据就得大动干戈（产生高频）。
    *   **余弦**（配合 DCT 的镜像特性）像是一个灵活的大师，它能通过“镜像”把数据的头尾平滑地接起来，消除了突变。**没有突变 = 不需要高频 = 数据可以被极大压缩。**

这就是为什么 JPEG 图片（也是用 DCT）和 FAST 算法都选余弦的原因！

没问题！为了让你彻底理解 DCT 为什么选择“余弦（Cosine）”而不是其他函数，我们需要回到数学最基础的部分，重新认识一下三角函数中的**余弦函数**。

我们把复杂的数学定义抛在一边，用最直观的**“圆”**和**“波”**来理解它。

---

### 1. 什么是余弦？（从圆开始）

想象一个**单位圆**（半径为 1 的圆），圆心在坐标轴的原点 $(0,0)$。
现在，有一根指针从 $X$ 轴的正方向（最右边）开始，**逆时针**旋转。

*   **角度 ($\theta$)**：指针转过的角度。
*   **余弦 ($\cos \theta$)**：就是指针尖端在 **X 轴上的投影长度**（也就是横坐标）。

**关键点演示：**

1.  **开始时 (0°)**：指针平躺在右边。
    *   投影长度是完整的半径。
    *   所以：$\cos(0°) = 1$ （这是最大值）。
2.  **转到顶端 (90°)**：指针竖直向上。
    *   它在 X 轴上没有投影（投影是个点）。
    *   所以：$\cos(90°) = 0$。
3.  **转到最左边 (180°)**：指针平躺在左边。
    *   投影长度是半径，但在负方向。
    *   所以：$\cos(180°) = -1$ （这是最小值）。
4.  **转到底部 (270°)**：指针竖直向下。
    *   在 X 轴上又没有投影了。
    *   所以：$\cos(270°) = 0$。

---

### 2. 把它展开就是“波”

如果我们把这个旋转的过程记录下来：
*   **横轴**：时间（或者角度）。
*   **纵轴**：余弦值（X轴投影长度）。

你会画出一条优美的波浪线，这就是**余弦波**。

**它的三个核心特征（这在 DCT 中至关重要）：**

1.  **起点在最高处**：
    *   这是余弦 ($\cos$) 和正弦 ($\sin$) 最大的区别。
    *   $\sin(0) = 0$（从 0 开始往上冲）。
    *   $\cos(0) = 1$（从最高点开始往下滑）。
    *   **为什么 DCT 选余弦？** 很多现实信号（比如图片像素、手势位置）相邻之间是相关的，通常不会突然从 0 开始剧烈跳变。余弦的“能量集中在低频”特性更适合描述这种平滑信号。

2.  **周期性**：
    *   它周而复始。每转一圈 ($360°$ 或 $2\pi$)，波形就重复一次。

3.  **对称性**：
    *   $\cos(-x) = \cos(x)$。
    *   这是一个“偶函数”，左右对称。

---

### 3. 频率：波的“胖瘦”

在 DCT 公式里，你会看到类似 $\cos(k \cdot n)$ 的写法。这里的 $k$ 就是**频率**。
它决定了波震动的快慢。

*   **低频 (k=1)**：波浪很宽，变化很慢。
    *   *就像机器人缓慢地伸手。*
*   **高频 (k=10)**：波浪很窄，上下跳动极快。
    *   *就像机器人的手在剧烈颤抖。*

**可视化的例子：**
想象一条绳子，你抓着一头抖动：
*   **$\cos(1x)$**：整条绳子像跳绳一样晃动（大轮廓）。
*   **$\cos(2x)$**：绳子中间出现一个不动的点，两边反着晃。
*   **$\cos(10x)$**：绳子像蛇一样密密麻麻地扭动。

---

### 4. 为什么这对 FAST 算法很重要？

结合刚才讲的 FAST 和 DCT：

1.  **任何动作 = 不同频率余弦波的叠加。**
    这就像做菜：
    *   动作 = 1勺“低频波”（大动作） + 0.1勺“中频波”（小转折） + 0.001勺“高频波”（微小抖动）。

2.  **余弦是最好的“积木”。**
    因为机器人的动作通常是平滑的（物理惯性限制了它不能瞬移）。
    *   平滑的信号 $\approx$ 低频余弦波。
    *   这意味着我们只需要**前几个**低频的余弦波就能拼出动作的大致模样。
    *   剩下的几百个高频余弦波，系数都是 0，直接扔掉。这就是**压缩**的原理。

### 总结
余弦函数 $\cos(x)$ 就是一个**从 1 开始、在 -1 和 1 之间来回摆动的波**。
*   在 DCT 中，我们改变它的**频率**（摆动速度），以此作为尺子去衡量原始数据中包含多少“慢动作”和多少“快抖动”。

---



